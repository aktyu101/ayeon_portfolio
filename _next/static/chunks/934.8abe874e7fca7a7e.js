"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[934],{6812:function(s,e,l){l.d(e,{Z:function(){return i}});var c=l(9506),a=l(8056);function i(s){let{id:e,contents:l}=s,i=a.J.findListById(e);return(0,c.jsxs)("article",{children:[(0,c.jsxs)("header",{children:[(0,c.jsx)("h1",{className:"text-[28px] pt-[60px]",children:i.name}),(0,c.jsxs)("div",{className:"flex flex-nowrap gap-[7px] pt-[8px] pb-[15px] text-[#666] border-b-[1px] border-black items-center",children:[(0,c.jsx)("span",{className:"text-[18px]",children:i.period}),(0,c.jsx)("span",{className:"text-[14px]",children:"|"}),(0,c.jsx)("span",{className:"text-[18px]",children:i.description})]})]}),(0,c.jsx)("section",{className:"pt-[50px]",children:l})]})}},6934:function(s,e,l){l.r(e),l.d(e,{default:function(){return n}});var c=l(9506),a=l(6812),i=l(9993);function n(){return(0,c.jsx)(a.Z,{id:1,contents:(0,c.jsx)(r,{})})}let r=()=>{let s=(0,i.m6)("text-[20px] mb-[30px] leading-[40px] indent-5 bg-slate-200"),e=(0,i.m6)("text-[18px] leading-[40px] text-[#2742BE] "),l=(0,i.m6)("text-[#333] indent-5 leading-[25px]"),a=(0,i.m6)("text-[17px] pb-[5px]"),n=(0,i.m6)("pb-[30px]"),r=(0,i.m6)("text-[red]"),d=(0,i.m6)("pb-[15px]");return(0,c.jsx)(c.Fragment,{children:(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{children:[(0,c.jsx)("p",{className:s,children:"PART1. 데이터 모델의 이해"}),(0,c.jsxs)("ul",{className:"pl-[10px]",children:[(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"모델링의 정의"}),(0,c.jsx)("p",{className:l,children:"-복잡한 현실세계를 일정한 표기법에 따라 단순화해 표현하는 일"}),(0,c.jsx)("p",{className:l,children:"-현실 세계의 비즈니스 프로세스와 데이터 요구 사항을 추상적이고 구조화된 형태로 표현하는 과정"}),(0,c.jsx)("p",{className:l,children:"-데이터 베이스의 구조와 관계를 정의하며, 이를 통해 데이터의 저장, 조작, 관리 방법을 명확하게 정의"})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"모델링의 특징"}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 단순화(Simplification)"}),(0,c.jsxs)("p",{className:l,children:["-현실을 단순화하여 핵심 요소에 집중하고",(0,c.jsxs)("span",{className:r,children:[" ","불필요한 세부 사항을 제거"]})]}),(0,c.jsx)("p",{className:l,children:"-단순화를 통해 복잡한 현실 세계를 이해하고 표현하기 쉬워짐"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 추상화(Abstraction)"}),(0,c.jsxs)("p",{className:l,children:["-현실세계를 일정한 형식에 맞추어"," ",(0,c.jsx)("span",{className:r,children:" 간략하게"})," 대략적으로 표현하는 과정"]}),(0,c.jsx)("p",{className:l,children:"-다양한 현상을 일정한 양식인 표기법에 따라 표현"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 명확화(Clarity)"}),(0,c.jsxs)("p",{className:l,children:["-대상에 대한 애매모호함을 최대한 제거하고",(0,c.jsxs)("span",{className:r,children:[" ","정확하게 현상을 기술"]}),"하는 과정"]}),(0,c.jsx)("p",{className:l,children:"-명확화를 통해 모델을 이해하는 이들의 의사소통을 원활히 함"})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"데이터 모델링 유의점"}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 중복(Duplication)"}),(0,c.jsx)("p",{className:l,children:"-한 테이블 또는 여러 테이블에 같은 정보를 저장하지 않도록 설계"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 비유연성(Inflexibility)"}),(0,c.jsx)("p",{className:l,children:"-사소한 업무 변화에 대해서도 잦은 모델 변경이 되지 않도록 주의"}),(0,c.jsx)("p",{className:l,children:"-데이터 정의를 프로세스와 분리"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 비일관성(Inconsistency)"}),(0,c.jsx)("p",{className:l,children:"-데이터베이스 내의 정보가 모순되거나 상반된 내용을 갖는 상태를 의미"}),(0,c.jsx)("p",{className:l,children:"-데이터간 상호연관 관계를 명확히 정의"}),(0,c.jsx)("p",{className:l,children:"-데이터 품질 관리 필요"}),(0,c.jsx)("p",{className:l,children:"-데이터의 중복이 없더라도 비일관성은 발생할 수 있음"})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"데이터 모델링의 3가지 요소"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-대상(Entity): 업무가 관리하고자 하는 대상(객체)"}),(0,c.jsx)("p",{className:l,children:"-속성(Attribute): 대상들이 갖는 속성(하나의 특징으로 정의될 수 있는 것)"})," ",(0,c.jsx)("p",{className:l,children:"-관계(Relationship): 대상들 간의 관계"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"데이터 모델링의 3단계"}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 개념적 모델링"}),(0,c.jsx)("p",{className:l,children:"-업무 중심적이고 포괄적(전사적)인 수준의 모델링"}),(0,c.jsx)("p",{className:l,children:(0,c.jsx)("span",{className:r,children:"-추상화 수준이 가장 높음"})}),(0,c.jsx)("p",{className:l,children:"-업무를 분석한 뒤 업무의 핵심 엔터티(Entity)를 추출하는 단계"}),(0,c.jsx)("p",{className:l,children:"-도출된 핵심 엔터티(Entity)들과의 관계들을 표현하기 위해 ERD 작성"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 논리적 모델링"}),(0,c.jsx)("p",{className:l,children:"-개념적 모델링의 결과를 토대로 세부속성, 식별자, 관계 등을 표현하는 단계"}),(0,c.jsx)("p",{className:l,children:"-데이터 구조를 정의하기 때문에 비슷한 업무나 프로젝트에서 동일한 형태의 데이터 사용"}),(0,c.jsx)("p",{className:l,children:"-동일한 논리적 모델을 사용하는 경우 쿼리도 재사용 가능"}),(0,c.jsx)("p",{className:l,children:"-데이터 정규화 수행"}),(0,c.jsx)("p",{className:l,children:"-재사용성이 높은 논리적 모델은 유지보수가 용이해짐"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 물리적 모델링"}),(0,c.jsx)("p",{className:l,children:"-논리 모델링이 끝나면 이를 직접 물리적으로 생성하는 과정"}),(0,c.jsx)("p",{className:l,children:"-데이터베이스 성능, 디스크 저장구조, 하드웨어의 보안성, 가용성 등을 고려"}),(0,c.jsx)("p",{className:l,children:"-가장 구체적인 데이터 모델링"}),(0,c.jsx)("p",{className:l,children:"-데이터의 중복이 없더라도 비일관성은 발생할 수 있음"}),(0,c.jsx)("p",{className:l,children:(0,c.jsx)("span",{className:r,children:"-추상화 수준이 가장 낮음(가장 구체적인 모델링이므로)"})})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"데이터 모델의 표기법(ERD : Entity Relationship Diagram)"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-엔터티와 엔터티 간의 관계를 시각적으로 표현한 다이어그램"}),(0,c.jsx)("p",{className:l,children:"-1976년 피터 첸이 만든 표기법, 데이터 모델링 표준으로 사용"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"ERD 작성 절차(6단계)"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"1. 엔터티를 도출한 후 그린다"}),(0,c.jsx)("p",{className:l,children:"2. 엔터티 배치"}),(0,c.jsx)("p",{className:l,children:"3. 엔터티 간의 관계를 설정"}),(0,c.jsx)("p",{className:l,children:"4. 관계명을 서술"}),(0,c.jsx)("p",{className:l,children:"5. 관계의 참여도 기술"}),(0,c.jsx)("p",{className:l,children:"6. 관계의 필수 여부를 확인"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"엔터티의 개념"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-현실 세계에서 독립적으로 식별 가능한 객체나 사물을 나타냄"}),(0,c.jsx)("p",{className:l,children:"-엔터티는 업무상 분석해야 하는 대상(Instance)들로 이루어진 집합"}),(0,c.jsx)("p",{className:l,children:"-인스턴스는 엔터티의 특정한 속성 값들로 구성되며, 엔터티의 개념을 현실에서 구체적으로 나타낸 것 (예) 엔터티와 속성, 인스턴스 등의 관계)"}),(0,c.jsxs)("p",{className:"rounded-lg bg-slate-100 p-[20px] my-[10px] w-auto",children:[(0,c.jsx)("p",{className:l,children:"-엔터티(Entity) : 학생"}),(0,c.jsx)("p",{className:l,children:"-속성(Attribute) : 학번, 이름, 학과 등"}),(0,c.jsx)("p",{className:l,children:"-식별자(Identifier) : 학번(고유한 학번으로 각 학생을 식별)"}),(0,c.jsx)("p",{className:l,children:"-인스턴스 : 특정 학생의 데이터(학번:32181528/이름:홍길동/학과:컴퓨터공학)"})]})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"엔터티의 특징"}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 유일한 식별자에 의해 식별 가능"}),(0,c.jsx)("p",{className:l,children:"-인스턴스가 식별자에 의해 한 개씩만 존재하는 지 검증 필요"}),(0,c.jsx)("p",{className:l,children:"-유일한 식별자는 그 엔터이의 인스턴스만의 고유 이름(ex. 이름은 동명이인이 있을 수 있으므로 사번, 학번 등이 고유식별자)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 해당 업무에 필요하고 관리하고자 하는 정보"}),(0,c.jsx)("p",{className:l,children:"-설계하는 업무의 시스템 구축에 필요한 정보여야 함(ex. 학교 시스템 구축 시 학생 정보 필요, 다른 업무엔 학생 정보 불필요)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 인스턴스들의 집합"}),(0,c.jsx)("p",{className:l,children:"-영속적으로 존재하는 2개 이상의 인스턴스의 집합"}),(0,c.jsx)("p",{className:l,children:"-인스턴스가 한 개 밖에 없는 엔터티는 집합이 아니므로 성립이 안 됨"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"4. 엔터티는 반드시 속성을 지님"}),(0,c.jsx)("p",{className:l,children:"-각 엔터티는 2개 이상의 속성을 지님"}),(0,c.jsx)("p",{className:l,children:"-하나의 인스턴스는 각각의 속성들에 대한 1개의 속성 값만을 가짐"}),(0,c.jsxs)("p",{className:l,children:["","(ex. 학생 엔터티에서 한 학생의 데이터(인스턴스)의 이름(속성)정보에는 반드시 한 값만 저장됨)"]})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"5.엔터티는 업무 프로세스에 의해 이용"}),(0,c.jsx)("p",{className:l,children:"-업무적으로 필요해 선정했지만 실제 이용되지 않으면 잘못 설계된 것"}),(0,c.jsx)("p",{className:l,children:"-모델링 시 발견하기 어려운 경우 데이터 모델 검증이나 상관 모델링 시 단위 프로세스 교차검증으로 문제 도출"}),(0,c.jsx)("p",{className:l,children:"-누락된 프로세스의 경우 추후 해당 프로세스 추가"}),(0,c.jsx)("p",{className:l,children:"-반대로 사용되지 않는 고립 엔터티는 제거 필요"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"6. 다른 엔터티와 최소 1개 이상의 관계 성립"}),(0,c.jsx)("p",{className:l,children:"-엔터티는 업무적 연관성을 갖고 다른 엔터티와 연관의 의미를 가짐"}),(0,c.jsx)("p",{className:l,children:"-관계가 없는 엔터티 도출은 부적절한 엔터티이거나 적절한 관계를 찾지 못한 것"})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"엔터티의 분류"}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["1)"," 유형과 무형에 따른 분류"]}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 유형엔터티"}),(0,c.jsx)("p",{className:l,children:"-물리적 형태가 있음(실체가 있는 대상)"}),(0,c.jsx)("p",{className:l,children:"-안정적이며 지속적으로 활용되는 엔터티"}),(0,c.jsx)("p",{className:l,children:"-업무적으로 구분하기가 가장 용이한 엔터티(ex. 사원, 물품, 감사 등)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 개념엔터티"}),(0,c.jsx)("p",{className:l,children:"-물리적인 형태 없음"}),(0,c.jsx)("p",{className:l,children:"-관리해야 할 개념적 정보로부터 구분되는 엔터티(ex. 조직, 보험상품 등)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 사건엔터티"}),(0,c.jsx)("p",{className:l,children:"-업무 수행에 따라 발생하는 엔터티"}),(0,c.jsx)("p",{className:l,children:"-발생량이 많고 각종 통계자료에 이용(ex. 주문, 청구, 미납 등)"})]})]}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["2)"," 발생 시점에 따른 분류"]}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 기본엔터티"}),(0,c.jsx)("p",{className:l,children:"-그 업무에 원래 존재하는 정보"}),(0,c.jsx)("p",{className:l,children:"-다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성"}),(0,c.jsx)("p",{className:l,children:"-타 엔터티의 부모 역할을 하는 엔터티"}),(0,c.jsx)("p",{className:l,children:"-다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가짐(ex. 사원, 부서, 고객, 상품 등)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 중심엔터티"}),(0,c.jsx)("p",{className:l,children:"-기본엔터티로부터 발생되고 그 업무에서 중심적인 역할"}),(0,c.jsx)("p",{className:l,children:"-많은 데이터가 발생되고 다른 엔터티와의 관계를 통해 많은 행위 엔터티를 생성(ex. 계약, 사고, 청구, 주문, 매출 등)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 행위엔터티"}),(0,c.jsx)("p",{className:l,children:"-2개 이상의 부모엔터티로부터 발생"}),(0,c.jsx)("p",{className:l,children:"-자주 내용이 바뀌거나 데이터 양이 증가"}),(0,c.jsx)("p",{className:l,children:"-분석 초기 단계보다는 상세 설계 단계나 프로세스와 상관모델링을 진행하면서 도출"}),(0,c.jsxs)("p",{className:l,children:["","ex. 주문(고객과 상품 엔터티로 부터 발생하므로 행위엔터티이기도 함), 사원변경이력, 이력 등"]})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"엔터티의 명명"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"1. 현업에서 사용하는 용어 사용"}),(0,c.jsx)("p",{className:l,children:"2. 가능하면 약자 사용은 자제"}),(0,c.jsx)("p",{className:l,children:"3. 단수 명사 사용"}),(0,c.jsx)("p",{className:l,children:"4. 모든 엔터티에서 유일하게 이름 부여"}),(0,c.jsx)("p",{className:l,children:"5. 엔터티 생성 의미대로 이름 부어"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"엔터티, 인스턴스, 속성값의 관계"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-한 개의 엔터티는 2개 이상의 인스턴스의 집합이어야 한다(하나의 테이블은 두 개 이상의 행을 가짐)"}),(0,c.jsx)("p",{className:l,children:"-한 개의 엔터티는 2개 이상의 속성을 갖는다(하나의 테이블은 두 개 이상의 컬럼으로 구성됨)"}),(0,c.jsx)("p",{className:l,children:"-한 개의 속성은 1개의 속성값을 갖는다(각 컬럼의 값은 하나씩만 삽입 가능)"}),(0,c.jsx)("p",{className:l,children:"-속성은 엔터티에 속한 엔터티에 대한 자세하고 구체적인 정보를 나타냄, 각 속성은 구체적인 값을 가짐"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"속성의 특징"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다."}),(0,c.jsx)("p",{className:l,children:"-정해진 주식별자에 함수적 종속성을 가져야 한다."}),(0,c.jsx)("p",{className:l,children:"-하나의 속성은 한 개의 값만을 가진다(한 컬럼의 값은 각 인스턴스마다 하나씩만 저장)"}),(0,c.jsx)("p",{className:l,children:"-하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다"}),(0,c.jsx)("p",{className:l,children:"-하나의 인스턴스는 속성마다 반드시 하나의 속성값을 가진다"}),(0,c.jsxs)("p",{className:l,children:["","-",">","각 속성이 하나의 값을 갖고 있음을 의미(속성의 원자성)"]})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"함수적 종속성"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-한 속성의 값이 다른 속성의 값에 종속적인 관계를 갖는 특징을 말함"}),(0,c.jsx)("p",{className:l,children:"-즉 어떤 속성 A의 값에 의해 다른 속성 B도 유일하게 결정된다면, B는 A에 함수적으로 종속됐다 하고,"}),(0,c.jsxs)("p",{className:l,children:["-이를 수식으로 나타내면 A-",">","B라고 표현함"]})]})}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["1)"," 완전 함수적 종속"]}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-특정 칼럼이 기본기에 대해 완전히 종속될 때를 말함"}),(0,c.jsx)("p",{className:l,children:"-PK를 구성하는 컬럼이 2개 이상일 경우 PK(중복되지 않는 값) 값 모두에 의한 중속관계를 나타낼 때 완전 함수 종속성 만족"}),(0,c.jsxs)("p",{className:l,children:["ex","(주문번호 + 제품번호)에 의해 수량 컬럼의 값이 결정됨"]})]})}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["2)"," 부분 함수적 종속"]}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-기본키 전체가 아니라, 기본키 일부에 대해 종속될 때를 말함"}),(0,c.jsxs)("p",{className:l,children:["ex",".수강기록 테이블에서 학생번호와 과목이 PK라고 가정할 때, 과목에 의해서도 교수가 결정되면 부분 함수적 종속 관계"]})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"속성의 분류"}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["1)"," 속성의 특징에 따른 분류"]}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 기본 속성"}),(0,c.jsx)("p",{className:l,children:"-업무로부터 추출된 모든 속성"}),(0,c.jsx)("p",{className:l,children:"-엔터티에 가장 일반적으로 많이 존재하는 속성"}),(0,c.jsxs)("p",{className:l,children:["","ex. 원금, 예치기간 등"]})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 설계속성"}),(0,c.jsx)("p",{className:l,children:"-기본 상품 외에 업무를 규칙화하기 위해 새로 만들어지거나 기본 속성을 변형하여 만들어지는 속성"}),(0,c.jsxs)("p",{className:l,children:["","ex. 상품코드, 지점코드, 에금분류 등"]})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 파생속성"}),(0,c.jsx)("p",{className:l,children:"-다른 속성에 의해 만들어지는 속성"}),(0,c.jsx)("p",{className:l,children:"-일반적으로 계산된 값들이 해당"}),(0,c.jsx)("p",{className:l,children:"-데이터 정합성을 유지하기 위해 가급적 적게 정의하는 것이 좋음"}),(0,c.jsxs)("p",{className:l,children:["","ex. 합계, 평균, 이자 등"]})]})]}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["2)"," 엔터티 구성방식에 따른 분류"]}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. PK(Primary Key, 기본키)"}),(0,c.jsx)("p",{className:l,children:"-인스턴스를 식별할 수 있는 속성"}),(0,c.jsx)("p",{className:a,children:"2. FK(Foreign Key, 외래키)"}),(0,c.jsx)("p",{className:l,children:"-다른 엔터티와의 관계에서 포함된 속성(참조관계를 가질 때)"}),(0,c.jsx)("p",{className:a,children:"3. 일반 속성"}),(0,c.jsx)("p",{className:l,children:"-엔터티에 포함되어 있고 Pk/FK에 포함되지 않는 속성"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 중심엔터티"}),(0,c.jsx)("p",{className:l,children:"-기본엔터티로부터 발생되고 그 업무에서 중심적인 역할"}),(0,c.jsx)("p",{className:l,children:"-많은 데이터가 발생되고 다른 엔터티와의 관계를 통해 많은 행위 엔터티를 생성(ex. 계약, 사고, 청구, 주문, 매출 등)"})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"3. 행위엔터티"}),(0,c.jsx)("p",{className:l,children:"-2개 이상의 부모엔터티로부터 발생"}),(0,c.jsx)("p",{className:l,children:"-자주 내용이 바뀌거나 데이터 양이 증가"}),(0,c.jsx)("p",{className:l,children:"-분석 초기 단계보다는 상세 설계 단계나 프로세스와 상관모델링을 진행하면서 도출"}),(0,c.jsxs)("p",{className:l,children:["","ex. 주문(고객과 상품 엔터티로 부터 발생하므로 행위엔터티이기도 함), 사원변경이력, 이력 등"]})]})]}),(0,c.jsxs)("h2",{className:e+"block text-[red]",children:["3)"," 분해 여부에 따른 속성"]}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 단일 속성"}),(0,c.jsx)("p",{className:l,children:"-하나의 의미로 구성된 경우"}),(0,c.jsxs)("p",{className:l,children:["","ex. 회원 ID, 이름 등"]}),(0,c.jsx)("p",{className:a,children:"2. 복합 속성"}),(0,c.jsx)("p",{className:l,children:"-여러개의 의미로 구성된 경우"}),(0,c.jsxs)("p",{className:l,children:["","ex. 주소(시, 군, 구 등으로 분해 가능) 등"]}),(0,c.jsx)("p",{className:a,children:"3. 다중값 속성"}),(0,c.jsx)("p",{className:l,children:"-속성에 여러 개의 값을 가질 수 있는 경우"}),(0,c.jsx)("p",{className:l,children:"-다중값 속성은 엔터티로 분해"}),(0,c.jsxs)("p",{className:l,children:["","ex. 상품 리스트 등"]})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"속성의 명명규칙"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"1. 해당 업무에서 사용하는 이름을 부여"}),(0,c.jsx)("p",{className:l,children:"2. 서술식 속성명은 사용하지 않음"}),(0,c.jsx)("p",{className:l,children:"3. 약어의 사용으 가급적 제한"}),(0,c.jsx)("p",{className:l,children:"4. 전체 데이터 모델에서 유일한 명칭"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"도메인(Domain)"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-도메인은 각 속성이 가질 수 있는 값의 범위를 의미함"}),(0,c.jsx)("p",{className:l,children:"-엔터티 내에서 속성에 대한 데이터 타입과 크기, 제약사항을 지정하는 것이다."})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"관계의 개념"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-관계는 엔터티간의 연관성을 나타낸 개념"}),(0,c.jsx)("p",{className:l,children:"-관계를 정의할 때는 인스턴스(각 행 데이터)간의 논리적인 연관성을 파악하여 정의"}),(0,c.jsx)("p",{className:l,children:"-엔터티를 어떻게 정의하느냐에 따라 변경되기도 함"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"관계의 종류"}),(0,c.jsxs)("ul",{children:[(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"1. 존재적 관계"}),(0,c.jsx)("p",{className:l,children:"-한 엔터티의 존재가 다른 엔터티의 존재에 영향을 미치는 관계"}),(0,c.jsx)("p",{className:l,children:"-엔터티 간의 연관된 상태를 의미"}),(0,c.jsxs)("p",{className:l,children:[""," ex. 부서 엔터티가 삭제되면 사원 엔터티의 존재가 영향을 미침"]})]}),(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:a,children:"2. 행위적 관계"}),(0,c.jsx)("p",{className:l,children:"-엔터티 간의 어떤 행위가 있는 것을 의미"}),(0,c.jsxs)("p",{className:l,children:[""," ex. 고객 엔터티의 행동에 의해 주문 엔터티가 발생"]}),(0,c.jsx)("p",{className:l,children:"* ERD 에서는 존재관계와 행위관계를 구분하지 않는다."})]})]})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"관계의 구성"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"1. 관계명"}),(0,c.jsx)("p",{className:l,children:"2. 차수(Cardinality)"}),(0,c.jsx)("p",{className:l,children:"3. 선택성(Optionality)"})]})})]}),(0,c.jsxs)("li",{className:n,children:[(0,c.jsx)("h2",{className:e,children:"관계의 차수(Cardinality)"}),(0,c.jsx)("ul",{children:(0,c.jsxs)("li",{className:d,children:[(0,c.jsx)("p",{className:l,children:"-한 엔터티의 레코드(인스턴스)가 다른 엔터티의 레코드(인스턴스)와 어떻게 연결되는지를 나타내는 표현"}),(0,c.jsx)("p",{className:l,children:"-주로 1:1, 1:N, N:M 등으로 표현"}),(0,c.jsxs)("p",{className:"rounded-lg bg-slate-100 p-[20px] my-[10px] w-auto",children:[(0,c.jsx)("p",{className:l,children:"1) 1 대 1 관계"}),(0,c.jsx)("p",{className:l,children:"완전 1 대 1 관계"}),(0,c.jsx)("p",{className:l,children:"- 하나의 엔터티에 관계되는 엔터티가 반드시 하나로 존재하는 경우"}),(0,c.jsxs)("p",{className:l,children:["","ex. 사원은 반드시 소속 부서가 있어야 함"]}),(0,c.jsx)("br",{}),(0,c.jsx)("p",{className:l,children:"선택적 1대 1 관계"}),(0,c.jsx)("p",{className:l,children:"- 하나의 엔터티에 관계되는 엔터티가 하나이거나 없을 수 있는 경우"}),(0,c.jsxs)("p",{className:l,children:["","ex. 사원은 하나의 소속 부서가 있거나 아직 발령전이면 없을 수 있음"]})]}),(0,c.jsxs)("p",{className:"rounded-lg bg-slate-100 p-[20px] my-[10px] w-auto",children:[(0,c.jsx)("p",{className:l,children:"2) 1 대 N 관계"}),(0,c.jsx)("p",{className:l,children:"엔터티 하나의 행에 다른 엔터티의 값이 여러 개 있을 수 있는 관계"}),(0,c.jsxs)("p",{className:l,children:["","ex. 고객은 여러 개 계좌를 소유할 수 있음"]}),(0,c.jsx)("br",{}),(0,c.jsx)("p",{className:l,children:"선택적 1대 1 관계"}),(0,c.jsx)("p",{className:l,children:"- 하나의 엔터티에 관계되는 엔터티가 하나이거나 없을 수 있는 경우"}),(0,c.jsxs)("p",{className:l,children:["","ex. 사원은 하나의 소속 부서가 있거나 아직 발령전이면 없을 수 있음"]})]}),(0,c.jsxs)("p",{className:"rounded-lg bg-slate-100 p-[20px] my-[10px] w-auto",children:[(0,c.jsx)("p",{className:l,children:"3) M 대 N 관계"}),(0,c.jsx)("p",{className:l,children:"-두 엔터티가 다대다의 연결 관계를 가지고 있음"}),(0,c.jsx)("p",{className:l,children:"-이 경우 조인 시 카테시안 곱이 발생하므로 두 엔터티를 연결하는 연결엔터티의 추가로 1 대 N 관계로 해소할 필요가 있음"}),(0,c.jsxs)("p",{className:l,children:["","ex. 한 학생이 여러 강의를 수강할 수 있고, 한 강의 기준으로도 여러 학생이 보유할 수 있음"]}),(0,c.jsxs)("p",{className:l,children:["","-",">","이 두 엔터티의 연결엔터티로는 구매이력 엔터티가 필요함"]})]})]})})]})]})]})})})}},8056:function(s,e,l){l.d(e,{J:function(){return i}});class c{get listSortedByDate(){return[...this.list].sort((s,e)=>new Date(s.startPeriod)==new Date(e.startPeriod)?0:new Date(s.startPeriod)>new Date(e.startPeriod)?-1:new Date(s.startPeriod)<new Date(e.startPeriod)?1:void 0)}findListById(s){return this.list.find(e=>e.id===s)}constructor(s=[]){this.list=s}}class a{get url(){return"images/portfolio/".concat(this.imageUrl)}get period(){return"".concat(this.startPeriod,"~").concat(this.endPeriod)}constructor(s,e="",l=null,c=null,a=null,i=null,n){this.id=s,this.name=e,this.imageUrl=l,this.startPeriod=c,this.endPeriod=a,this.type=i,this.description=n}}let i=new c([new a(1,"SQLD 요점 정리","portfolio01.png","2024.04.23","2024.04.28","SQL","1장. 데이터 모델링의 이해"),new a(2,"study02","portfolio01.png","2024.01.01","2024.04.05","JAVASCRIPT","des"),new a(3,"study03","portfolio01.png","2024.04.05","2024.04.05","HTML&CSS","des"),new a(4,"study04","portfolio01.png","2024.04.02","2024.04.05","HTML&CSS","des"),new a(5,"study05","portfolio01.png","2024.04.03","2024.04.05","HTML&CSS","des"),new a(6,"study06","portfolio01.png","2023.12.04","2024.04.05","HTML&CSS","des"),new a(1,"study01","portfolio01.png","2024.04.04","2024.04.05","HTML&CSS","des"),new a(2,"study02","portfolio01.png","2024.01.01","2024.04.05","JAVASCRIPT","des"),new a(3,"study03","portfolio01.png","2024.04.05","2024.04.05","HTML&CSS","des"),new a(4,"study04","portfolio01.png","2024.04.02","2024.04.05","HTML&CSS","des"),new a(5,"study05","portfolio01.png","2024.04.03","2024.04.05","HTML&CSS","des"),new a(6,"study06","portfolio01.png","2023.12.04","2024.04.05","HTML&CSS","des")])}}]);